1、前面学习过@MappedSuperclass，可以把一些公共的属性提取到添加该注解的类里，如id，creteTime，updateTime等。该类不会生成表，
该类中相应的字段都会生成在子类中。该类没有被@Entity注释，不是一个实体。

2、@Inheritance
    JPA为我们提供了@Inheritance注解来控制实体时间有继承关系时，在数据库中如何生成对应的表。该注解需要添加在根实体上，如果没有
添加@Inheritance注解，或添加了没有指定InheritanceType那么将使用SINGLE_TABLE（单表）映射策略。
    下面我们通过例子来看一下三个继承策略有什么不同，如书籍（Book）下有两个子类，纸质书（PrintBook）、电子书（EBook）。

2.1、SINGLE_TABLE（单表映射策略）
    不添加@Inheritance或InheritanceType.SINGLE_TABLE（默认的策略）都会使用该策略。

    使用SINGLE_TABLE策略时，子类不会生成对应的表，所以@Table注解多余了。而父类的表中会多出一个dtype字段，由JPA来维护，字段的值是类的简单名称，用来标识是属于哪一类的。
子类的特有字段都会在这张表上。

    适用场景：父类和子类之间差异不大，父类维护了大量的相同字段，子类只有少量字段不同，且子类字段可以为空的情况下，才能使用。

2.2、JOINED（关联策略）
    特定于子类的字段被映射到一个单独的表，而不是父类的公共字段，并执行联接来实例化子类。

    会生成多张表，在父类对应的表中存放了公共的字段，在子类对应的表中，存放了子类特有的字段，还有一个指向父类id的外键。
    在执行新增操作时，如果是子类新增，会执行两条insert语句，分别插入到父类对应的表和自己对应的表中。
    在使用父类的Repository进行findAll查询时，父类对应的表会左外连接所有子类所对应的表进行查询，数据量大，且子类多时，发杂的SQL，会有性能问题。
    在使用子类自己的Repository进行findAll查询时，子类对应的表会内连接类对对应的表。


2.3、TABLE_PER_CLASS（每个实体对应一个表）

    使用TABLE_PER_CLASS策略时，不能使用主键自增策略。因为每一个类都会生成一张表，当使用父类的Repository进行查询时，会把这些表的数据都
抓出来，然后每一个表里面都会有各自的主键，如果用自增策略的话，两张表中的主键可能会一样，比如说book表中有id为1的记录，ebook表中也有id为
1的记录。这样把他们聚合到一块的时候，就会有两个id为1的book对象。所以不能使用主键自增策略。

    会生成多张表，父类对应的表中中有自己的字段。子类对应的表中当中除了有自己特有的字段外，也有父类所有的字段。
    执行新增操作时，执行一次insert到自己对应的表。
    在使用父类的Repository进行findAll查询时，会将所有的表进行UNION ALL操作。
    在使用子类自己的Repository进行findAll查询时，单表SELECT。
    适用于父类和子类差以比较大的时候，如果继承体系比较小时。


